Взять реализованный код в рамках семинара 4 и продемонстрировать применение принципов, усвоенных на семинаре. Нужно в проекте прокомментировать участки кода, которые рефакторим, какой принцип применяем и почему. Формат сдачи: ссылка на гитхаб проект.

При выполнении домашнего задания к семинару #6 использовались следющие принципы ООП:

абстракция;
наследование;
полиморфизм;
инкапсуляция;
а также принципы SOLID:

S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну задачу. Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы;

В качестве примера, созданы два класса: StudentGroup - отвечает за объединение сущности Student в группу и объдиняет функционал управления данной группой; тогда для реализации учебной группы мы расширяем класс StudentGroup наследником StudyGroup, который добавляет к студентам преподавателя группы(класс Teacher) и соответсвующий функционал.

O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для модификации. Чтобы не сломать логику в классе-родителе, мы наследуем от него и реализуем что-то своё, и используем свой класс;

В качестве примера, созданы два родительских класса User, UserGroup, от которых созданы наследники класса для реализации необходимого функционала, такие как: Student, Teacher, StudentGroup, TeacherGroup.

L(Liskov’s Substitution Principle) - принцип подстановки барбары лисков - объекты в программе можно заменить их наследниками без изменения свойств программы;

*Благодаря тому что реализованые сущности программы опираются на абстрактные семейства объектов, то програмные сущности могут взаимозаменять друг друга в рамках одного семейства *

I(Interface Segregation Principle) - принцип разделения интерфейса - много специализированных интерфейсов лучше, чем один общий;

Для каждого класса организорваны интерфейсы

D(Dependency Inversion Principle) - принцип инверсии зависимостей - зависимость на абстракциях. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Организованы родительские классы и их наследники, где первые не зависят от вторых и наоборот